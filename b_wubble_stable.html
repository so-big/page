<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Viewer with WebGL 3D Effect</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
        }
        #container {
            display: flex;
            height: 100%;
            flex-direction: column;
        }
        #main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        #sidebar-left {
            width: 200px;
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            height: 100%;
        }
        #canvas-container {
            flex-grow: 1;
            position: relative;
            background-color: #ecf0f1;
            overflow: hidden;
        }
        #bottom-menu {
            height: 50px;
            background-color: #34495e;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #canvas, #drawingCanvas, #cursorCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #canvas {
            z-index: 1;
        }
        #drawingCanvas {
            z-index: 998;
        }
        #cursorCanvas {
            z-index: 999;
            pointer-events: none;
        }
        button {
            margin: 10px;
            padding: 10px;
            background-color: #2980b9;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #3498db;
        }
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        #colorButton {
            background-color: red; /* สีเริ่มต้น */
            width: 50px;
            height: 30px;
            padding: 0;
        }
        input[type="file"] {
            display: none; /* ซ่อน input file */
        }
    </style>
</head>
<body>

<div id="container">
    <div id="main-content">
        <div id="sidebar-left">
            <h3>Menu</h3>
            <button onclick="document.getElementById('imageInput').click()">Open Image</button>
            <input type="file" id="imageInput" accept="image/*" onchange="loadNewImage(event)">
            <button onclick="exitApp()">Exit</button>
            <div>
                <button id="colorButton" onclick="changeColor()">Red</button>
                <label for="penSize">Pen Size: <span id="penSizeValue">50</span></label>
                <input type="range" id="penSize" min="1" max="300" value="50">
                <label for="penAlpha">Alpha: <span id="penAlphaValue">0.30</span></label>
                <input type="range" id="penAlpha" min="0" max="1" step="0.01" value="0.3">
                <label for="penBlur">Blur: <span id="penBlurValue">40</span></label>
                <input type="range" id="penBlur" min="0" max="100" value="40">
            </div>
        </div>
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <canvas id="drawingCanvas"></canvas>
            <canvas id="cursorCanvas"></canvas>
        </div>
    </div>
    <div id="bottom-menu">
        <p>ฟังก์ชั่น</p>
        <button onclick="startAutoUpDown()">Up-Down</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const cursorCanvas = document.getElementById('cursorCanvas');
    const drawingCtx = drawingCanvas.getContext('2d');
    const cursorCtx = cursorCanvas.getContext('2d');
    let img = new Image();
    let scale = 1;
    let isDrawing = false;
    let penSize = 50;
    let penAlpha = 0.3;
    let penBlur = 40;
    let animationStartTime = null;
    let penColor = 'red'; // ค่าเริ่มต้นของสีปากกา
    let isAnimating = false; // ตัวแปรควบคุมการวนลูป

    // Shader โปรแกรม
    const vertexShaderSource = `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_texCoord = a_texCoord;
        }
    `;

    const fragmentShaderSource = `
        precision mediump float;
        varying vec2 v_texCoord;
        uniform sampler2D u_image;
        uniform sampler2D u_depthMap;
        uniform float u_offset;
        void main() {
            vec4 depth = texture2D(u_depthMap, v_texCoord);
            float offsetY = depth.r * depth.a * u_offset;
            vec2 displacedCoord = vec2(v_texCoord.x, v_texCoord.y + offsetY);
            if (displacedCoord.y < 0.0 || displacedCoord.y > 1.0) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
            } else {
                gl_FragColor = texture2D(u_image, displacedCoord);
            }
        }
    `;

    // อัพเดทค่า Pen Size
    const penSizeInput = document.getElementById('penSize');
    const penSizeValue = document.getElementById('penSizeValue');
    penSizeInput.addEventListener('input', function() {
        penSize = this.value;
        penSizeValue.textContent = penSize;
    });

    // อัพเดทค่า Alpha และปรับที่ drawingCanvas
    const penAlphaInput = document.getElementById('penAlpha');
    const penAlphaValue = document.getElementById('penAlphaValue');
    penAlphaInput.addEventListener('input', function() {
        penAlpha = parseFloat(this.value);
        penAlphaValue.textContent = penAlpha.toFixed(2);
        drawingCanvas.style.opacity = penAlpha;
    });

    // อัพเดทค่า Blur
    const penBlurInput = document.getElementById('penBlur');
    const penBlurValue = document.getElementById('penBlurValue');
    penBlurInput.addEventListener('input', function() {
        penBlur = this.value;
        penBlurValue.textContent = penBlur;
    });

    window.onload = function() {
        const imagePath = '01.jpg';
        img.crossOrigin = "Anonymous";
        img.src = imagePath;

        img.onload = function() {
            resizeCanvas();
            setupDrawingCanvas();
            setupCursorCanvas();
            initWebGL();
            render(0);
        };

        img.onerror = function() {
            alert('ไม่สามารถโหลดรูป 01.jpg ได้ กรุณารันผ่านเซิร์ฟเวอร์ (เช่น localhost) หรือตรวจสอบว่าไฟล์อยู่ในโฟลเดอร์เดียวกัน');
        };
    };

    function resizeCanvas() {
        const canvasWidth = window.innerWidth - 220;
        const canvasHeight = window.innerHeight - 50;
        const imageAspect = img.width / img.height;
        const canvasAspect = canvasWidth / canvasHeight;

        if (canvasAspect > imageAspect) {
            canvas.height = canvasHeight;
            canvas.width = canvasHeight * imageAspect;
        } else {
            canvas.width = canvasWidth;
            canvas.height = canvasWidth / imageAspect;
        }

        gl.viewport(0, 0, canvas.width, canvas.height);
    }

    function setupDrawingCanvas() {
        drawingCanvas.width = canvas.width;
        drawingCanvas.height = canvas.height;
        drawingCanvas.style.opacity = penAlpha;
    }

    function setupCursorCanvas() {
        cursorCanvas.width = canvas.width;
        cursorCanvas.height = canvas.height;
    }

    function exitApp() {
        window.close();
    }

    // WebGL Initialization
    let program, imageTexture, depthTexture;
    function initWebGL() {
        if (!gl) {
            alert('เบราว์เซอร์ของคุณไม่รองรับ WebGL');
            return;
        }

        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            console.error('Vertex Shader Error:', gl.getShaderInfoLog(vertexShader));
        }

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            console.error('Fragment Shader Error:', gl.getShaderInfoLog(fragmentShader));
        }

        program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program Link Error:', gl.getProgramInfoLog(program));
        }
        gl.useProgram(program);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const imageAspect = img.width / img.height;
        const canvasAspect = canvas.width / canvas.height;
        let xScale = 1.0;
        let yScale = 1.0;

        if (canvasAspect > imageAspect) {
            xScale = imageAspect / canvasAspect;
        } else {
            yScale = canvasAspect / imageAspect;
        }

        const positions = new Float32Array([
            -xScale, -yScale,  0, 1,
             xScale, -yScale,  1, 1,
            -xScale,  yScale,  0, 0,
             xScale,  yScale,  1, 0,
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
        gl.enableVertexAttribArray(positionLocation);
        gl.enableVertexAttribArray(texCoordLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 16, 0);
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 16, 8);

        imageTexture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, imageTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        depthTexture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, depthTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.uniform1i(gl.getUniformLocation(program, 'u_image'), 0);
        gl.uniform1i(gl.getUniformLocation(program, 'u_depthMap'), 1);
    }

    // ฟังก์ชันการวาดบน drawingCanvas
    drawingCanvas.addEventListener('mousedown', startDrawing);
    drawingCanvas.addEventListener('mousemove', draw);
    drawingCanvas.addEventListener('mouseup', stopDrawing);
    drawingCanvas.addEventListener('mouseout', stopDrawing);

    drawingCanvas.addEventListener('mousemove', showCursor);
    drawingCanvas.addEventListener('mouseout', clearCursor);

    function startDrawing(e) {
        isDrawing = true;
        drawingCtx.beginPath();
        draw(e);
    }

    function draw(e) {
        if (!isDrawing) return;

        const rect = drawingCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        drawingCtx.globalAlpha = penAlpha;
        drawingCtx.lineWidth = penSize;
        drawingCtx.lineCap = 'round';
        drawingCtx.strokeStyle = penColor;

        drawingCtx.lineTo(x, y);
        drawingCtx.stroke();
        drawingCtx.beginPath();
        drawingCtx.moveTo(x, y);

        if (penBlur > 0) {
            drawingCtx.globalAlpha = penAlpha;
            drawingCtx.shadowBlur = penBlur;
            drawingCtx.shadowColor = penColor;
            drawingCtx.lineTo(x, y);
            drawingCtx.stroke();
            drawingCtx.beginPath();
            drawingCtx.moveTo(x, y);
        }

        updateDepthTexture();
    }

    function stopDrawing() {
        isDrawing = false;
        drawingCtx.beginPath();
        drawingCtx.shadowBlur = 0;
    }

    function showCursor(e) {
        const rect = drawingCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        cursorCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);
        cursorCtx.beginPath();
        cursorCtx.arc(x, y, penSize / 2, 0, Math.PI * 2);
        cursorCtx.lineWidth = 2;
        cursorCtx.strokeStyle = 'black';
        cursorCtx.stroke();
    }

    function clearCursor() {
        cursorCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);
    }

    function updateDepthTexture() {
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, depthTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, drawingCanvas);
        render(0);
    }

    // แอนิเมชัน WebGL
    function render(offset) {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, imageTexture);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, depthTexture);

        gl.uniform1f(gl.getUniformLocation(program, 'u_offset'), offset * penAlpha * 0.1);

        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    function animateUpDown(timestamp) {
        if (!animationStartTime) animationStartTime = timestamp;
        const elapsed = (timestamp - animationStartTime) / 1000;
        const cycleDuration = 2.5; // ระยะเวลาหนึ่งรอบ (ขึ้น 1, หยุด 0.5, ลง 1)

        // คำนวณ elapsed ในรอบปัจจุบัน
        const cycleElapsed = elapsed % cycleDuration;

        let offset;
        if (cycleElapsed < 1) { // 0-1 วินาที: ขึ้น
            offset = -Math.sin(cycleElapsed * Math.PI);
        } else if (cycleElapsed < 1.5) { // 1-1.5 วินาที: หยุด
            offset = 0;
        } else { // 1.5-2.5 วินาที: ลง
            offset = Math.sin((cycleElapsed - 1.5) * Math.PI);
        }

        render(offset);

        if (isAnimating) {
            requestAnimationFrame(animateUpDown); // วนลูปต่อไป
        } else {
            drawingCanvas.style.zIndex = "998"; // สลับกลับเมื่อหยุด
            animationStartTime = null;
            render(0);
        }
    }

    function startAutoUpDown() {
        drawingCanvas.style.zIndex = "0";
        animationStartTime = null;
        isAnimating = true; // เริ่มการวนลูป
        requestAnimationFrame(animateUpDown);
    }

    // ฟังก์ชันเปลี่ยนสีปากกาและหยุดแอนิเมชัน
    function changeColor() {
        if (isAnimating) { // ถ้ากำลังวนลูป
            isAnimating = false; // หยุดแอนิเมชัน
            drawingCanvas.style.zIndex = "998"; // สลับ canvas กลับมา
            render(0); // รีเซ็ตการแสดงผล
        } else { // ถ้าไม่วนลูป ให้เปลี่ยนสี
            const color = prompt("กรุณาใส่สี (เช่น red, blue, #FF0000):", penColor);
            if (color) {
                penColor = color;
                document.getElementById('colorButton').style.backgroundColor = penColor;
                document.getElementById('colorButton').textContent = penColor;
            }
        }
    }

    // ฟังก์ชันโหลดรูปภาพใหม่
    function loadNewImage(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                img.src = e.target.result;
                img.onload = function() {
                    resizeCanvas();
                    setupDrawingCanvas();
                    setupCursorCanvas();
                    initWebGL();
                    render(0);
                };
            };
            reader.readAsDataURL(file);
        }
    }

    window.addEventListener('resize', function() {
        resizeCanvas();
        setupDrawingCanvas();
        setupCursorCanvas();
        initWebGL();
        render(0);
    });
</script>

</body>
</html>