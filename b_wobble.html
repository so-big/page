<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Viewer with WebGL 3D Effect</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
        }
        #container {
            display: flex;
            height: 100%;
            flex-direction: column;
        }
        #main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        #sidebar-left {
            width: 200px;
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            height: 100%;
            overflow-y: auto;
        }
        #canvas-container {
            flex-grow: 1;
            position: relative;
            background-color: #ecf0f1;
            overflow: hidden;
        }
        #bottom-menu {
            height: 50px;
            background-color: #34495e;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #canvas, #drawingCanvas, #drawingCanvasBlue, #cursorCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #canvas {
            z-index: 1;
        }
        #drawingCanvas, #drawingCanvasBlue {
            z-index: 998;
        }
        #cursorCanvas {
            z-index: 999;
            pointer-events: none;
        }
        button {
            margin: 10px;
            padding: 10px;
            background-color: #2980b9;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #3498db;
        }
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        #colorButton {
            background-color: red;
            width: 50px;
            height: 30px;
            padding: 0;
        }
        #red2Button {
            background-color: red;
            width: 50px;
            height: 30px;
            padding: 0;
        }
        #eraserButton {
            background-color: #ffffff;
            color: black;
            width: 50px;
            height: 30px;
            padding: 0;
        }
        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>

<div id="container">
    <div id="main-content">
        <div id="sidebar-left">
            <h3>Menu</h3>
            <button onclick="document.getElementById('imageInput').click()">Open Image</button>
            <input type="file" id="imageInput" accept="image/*" onchange="loadNewImage(event)">
            <button id="eraserButton" onclick="toggleEraser()">Eraser</button>
            <button onclick="exitApp()">Exit</button>
            <div>
                <button id="colorButton" onclick="changeColor('red')">Red</button>
                <label for="penSizeRed">Pen Size: <span id="penSizeValueRed">50</span></label>
                <input type="range" id="penSizeRed" min="1" max="300" value="50">
                <label for="penAlphaRed">Alpha: <span id="penAlphaValueRed">0.30</span></label>
                <input type="range" id="penAlphaRed" min="0" max="1" step="0.01" value="0.3">
                <label for="penBlurRed">Blur: <span id="penBlurValueRed">40</span></label>
                <input type="range" id="penBlurRed" min="0" max="100" value="40">
            </div>
            <div>
                <button id="red2Button" onclick="changeColor('red2')">RED2</button>
                <label for="penSizeRed2">Pen Size: <span id="penSizeValueRed2">50</span></label>
                <input type="range" id="penSizeRed2" min="1" max="300" value="50">
                <label for="penAlphaRed2">Alpha: <span id="penAlphaValueRed2">0.30</span></label>
                <input type="range" id="penAlphaRed2" min="0" max="1" step="0.01" value="0.3">
                <label for="penBlurRed2">Blur: <span id="penBlurValueRed2">40</span></label>
                <input type="range" id="penBlurRed2" min="0" max="100" value="40">
            </div>
            <div>
                <label for="gaussianBlur">Gaussian Blur: <span id="gaussianBlurValue">7</span></label>
                <input type="range" id="gaussianBlur" min="0" max="20" value="7">
                <label for="displacementAlpha">Displacement Alpha: <span id="displacementAlphaValue">1.00</span></label>
                <input type="range" id="displacementAlpha" min="0" max="1" step="0.01" value="1">
            </div>
        </div>
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <canvas id="drawingCanvas"></canvas>
            <canvas id="drawingCanvasBlue"></canvas>
            <canvas id="cursorCanvas"></canvas>
        </div>
    </div>
    <div id="bottom-menu">
        <p>ฟังก์ชั่น</p>
        <button onclick="startAutoUpDown()">Up-Down</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const drawingCanvasBlue = document.getElementById('drawingCanvasBlue');
    const cursorCanvas = document.getElementById('cursorCanvas');
    const drawingCtx = drawingCanvas.getContext('2d');
    const drawingCtxBlue = drawingCanvasBlue.getContext('2d');
    const cursorCtx = cursorCanvas.getContext('2d');
    let img = new Image();
    let scale = 1;
    let isDrawing = false;
    let penSizeRed = 50, penAlphaRed = 0.3, penBlurRed = 40;
    let penSizeRed2 = 50, penAlphaRed2 = 0.3, penBlurRed2 = 40;
    let gaussianBlurValue = 7;
    let displacementAlpha = 1.0;
    let animationStartTime = null;
    let penColor = 'red';
    let isAnimating = false;
    let currentLayer = 'red';
    let isErasing = false;

    // Create mixedCanvas once
    const mixedCanvas = document.createElement('canvas');
    const mixedCtx = mixedCanvas.getContext('2d');

    // Shader programs
    const vertexShaderSource = `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_texCoord = a_texCoord;
        }
    `;

    const fragmentShaderSource = `
        precision mediump float;
        varying vec2 v_texCoord;
        uniform sampler2D u_image;
        uniform sampler2D u_depthMap;
        uniform float u_offset;
        void main() {
            vec4 depth = texture2D(u_depthMap, v_texCoord);
            float offsetY = depth.r * u_offset;
            vec2 displacedCoord = vec2(v_texCoord.x, v_texCoord.y + offsetY);
            if (displacedCoord.y < 0.0 || displacedCoord.y > 1.0) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
            } else {
                gl_FragColor = texture2D(u_image, displacedCoord);
            }
        }
    `;

    // Debounce function
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    // Update Red values
    const penSizeInputRed = document.getElementById('penSizeRed');
    const penSizeValueRed = document.getElementById('penSizeValueRed');
    penSizeInputRed.addEventListener('input', debounce(function() {
        penSizeRed = this.value;
        penSizeValueRed.textContent = penSizeRed;
        updateDepthTexture();
    }, 200));

    const penAlphaInputRed = document.getElementById('penAlphaRed');
    const penAlphaValueRed = document.getElementById('penAlphaValueRed');
    penAlphaInputRed.addEventListener('input', debounce(function() {
        penAlphaRed = parseFloat(this.value);
        penAlphaValueRed.textContent = penAlphaRed.toFixed(2);
        drawingCanvas.style.opacity = penAlphaRed;
        updateDepthTexture();
    }, 200));

    const penBlurInputRed = document.getElementById('penBlurRed');
    const penBlurValueRed = document.getElementById('penBlurValueRed');
    penBlurInputRed.addEventListener('input', function() {
        penBlurRed = this.value;
        penBlurValueRed.textContent = penBlurRed;
    });

    // Update Red2 values
    const penSizeInputRed2 = document.getElementById('penSizeRed2');
    const penSizeValueRed2 = document.getElementById('penSizeValueRed2');
    penSizeInputRed2.addEventListener('input', debounce(function() {
        penSizeRed2 = this.value;
        penSizeValueRed2.textContent = penSizeRed2;
        updateDepthTexture();
    }, 200));

    const penAlphaInputRed2 = document.getElementById('penAlphaRed2');
    const penAlphaValueRed2 = document.getElementById('penAlphaValueRed2');
    penAlphaInputRed2.addEventListener('input', debounce(function() {
        penAlphaRed2 = parseFloat(this.value);
        penAlphaValueRed2.textContent = penAlphaRed2.toFixed(2);
        drawingCanvasBlue.style.opacity = penAlphaRed2;
        updateDepthTexture();
    }, 200));

    const penBlurInputRed2 = document.getElementById('penBlurRed2');
    const penBlurValueRed2 = document.getElementById('penBlurValueRed2');
    penBlurInputRed2.addEventListener('input', function() {
        penBlurRed2 = this.value;
        penBlurValueRed2.textContent = penBlurRed2;
    });

    // Update Gaussian Blur value
    const gaussianBlurInput = document.getElementById('gaussianBlur');
    const gaussianBlurValueDisplay = document.getElementById('gaussianBlurValue');
    gaussianBlurInput.addEventListener('input', function() {
        gaussianBlurValue = parseInt(this.value);
        gaussianBlurValueDisplay.textContent = gaussianBlurValue;
    });

    // Update Displacement Alpha value
    const displacementAlphaInput = document.getElementById('displacementAlpha');
    const displacementAlphaValueDisplay = document.getElementById('displacementAlphaValue');
    displacementAlphaInput.addEventListener('input', debounce(function() {
        displacementAlpha = parseFloat(this.value);
        displacementAlphaValueDisplay.textContent = displacementAlpha.toFixed(2);
        updateDepthTexture();
    }, 200));

    window.onload = function() {
        const imagePath = '01.jpg';
        img.crossOrigin = "Anonymous";
        img.src = imagePath;

        img.onload = function() {
            resizeCanvas();
            setupDrawingCanvas();
            setupCursorCanvas();
            initWebGL();
            render(0);
        };

        img.onerror = function() {
            alert('ไม่สามารถโหลดรูป 01.jpg ได้ กรุณารันผ่านเซิร์ฟเวอร์');
        };
    };

    function resizeCanvas() {
        const canvasWidth = window.innerWidth - 220;
        const canvasHeight = window.innerHeight - 50;
        const imageAspect = img.width / img.height;
        const canvasAspect = canvasWidth / canvasHeight;

        if (canvasAspect > imageAspect) {
            canvas.height = canvasHeight;
            canvas.width = canvasHeight * imageAspect;
        } else {
            canvas.width = canvasWidth;
            canvas.height = canvasWidth / imageAspect;
        }

        mixedCanvas.width = canvas.width;
        mixedCanvas.height = canvas.height;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }

    function setupDrawingCanvas() {
        drawingCanvas.width = canvas.width;
        drawingCanvas.height = canvas.height;
        drawingCanvas.style.opacity = penAlphaRed;

        drawingCanvasBlue.width = canvas.width;
        drawingCanvasBlue.height = canvas.height;
        drawingCanvasBlue.style.opacity = penAlphaRed2;
    }

    function setupCursorCanvas() {
        cursorCanvas.width = canvas.width;
        cursorCanvas.height = canvas.height;
    }

    function exitApp() {
        window.close();
    }

    // WebGL Initialization
    let program, imageTexture, depthTexture;
    function initWebGL() {
        if (!gl) {
            alert('เบราว์เซอร์ของคุณไม่รองรับ WebGL');
            return;
        }

        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            console.error('Vertex Shader Error:', gl.getShaderInfoLog(vertexShader));
        }

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            console.error('Fragment Shader Error:', gl.getShaderInfoLog(fragmentShader));
        }

        program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program Link Error:', gl.getProgramInfoLog(program));
        }
        gl.useProgram(program);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const imageAspect = img.width / img.height;
        const canvasAspect = canvas.width / canvas.height;
        let xScale = 1.0;
        let yScale = 1.0;

        if (canvasAspect > imageAspect) {
            xScale = imageAspect / canvasAspect;
        } else {
            yScale = canvasAspect / imageAspect;
        }

        const positions = new Float32Array([
            -xScale, -yScale,  0, 1,
             xScale, -yScale,  1, 1,
            -xScale,  yScale,  0, 0,
             xScale,  yScale,  1, 0,
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
        gl.enableVertexAttribArray(positionLocation);
        gl.enableVertexAttribArray(texCoordLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 16, 0);
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 16, 8);

        imageTexture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, imageTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        depthTexture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, depthTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.uniform1i(gl.getUniformLocation(program, 'u_image'), 0);
        gl.uniform1i(gl.getUniformLocation(program, 'u_depthMap'), 1);
    }

    // Drawing functions
    drawingCanvas.addEventListener('mousedown', startDrawing);
    drawingCanvas.addEventListener('mousemove', draw);
    drawingCanvas.addEventListener('mouseup', stopDrawing);
    drawingCanvas.addEventListener('mouseout', stopDrawing);

    drawingCanvasBlue.addEventListener('mousedown', startDrawing);
    drawingCanvasBlue.addEventListener('mousemove', draw);
    drawingCanvasBlue.addEventListener('mouseup', stopDrawing);
    drawingCanvasBlue.addEventListener('mouseout', stopDrawing);

    drawingCanvas.addEventListener('mousemove', showCursor);
    drawingCanvasBlue.addEventListener('mousemove', showCursor);
    drawingCanvas.addEventListener('mouseout', clearCursor);
    drawingCanvasBlue.addEventListener('mouseout', clearCursor);

    function startDrawing(e) {
        isDrawing = true;
        if (currentLayer === 'red') {
            drawingCtx.beginPath();
        } else {
            drawingCtxBlue.beginPath();
        }
        draw(e);
    }

    function draw(e) {
        if (!isDrawing) return;

        const rect = (currentLayer === 'red' ? drawingCanvas : drawingCanvasBlue).getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const ctx = currentLayer === 'red' ? drawingCtx : drawingCtxBlue;
        const penSize = currentLayer === 'red' ? penSizeRed : penSizeRed2;
        const penAlpha = currentLayer === 'red' ? penAlphaRed : penAlphaRed2;
        const penBlur = currentLayer === 'red' ? penBlurRed : penBlurRed2;
        const color = 'red';

        if (isErasing) {
            ctx.globalCompositeOperation = 'destination-out';
            ctx.globalAlpha = 1.0;
            ctx.lineWidth = penSize;
            ctx.lineCap = 'round';
            ctx.strokeStyle = 'rgba(0,0,0,1)';
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.globalCompositeOperation = 'source-over';
        } else {
            ctx.globalAlpha = penAlpha;
            ctx.lineWidth = penSize;
            ctx.lineCap = 'round';
            ctx.strokeStyle = color;

            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);

            if (penBlur > 0) {
                ctx.globalAlpha = penAlpha;
                ctx.shadowBlur = penBlur;
                ctx.shadowColor = color;
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, y);
            }
        }
    }

    function stopDrawing() {
        isDrawing = false;
        if (currentLayer === 'red') {
            drawingCtx.beginPath();
            drawingCtx.shadowBlur = 0;
        } else {
            drawingCtxBlue.beginPath();
            drawingCtxBlue.shadowBlur = 0;
        }
        updateDepthTexture();
    }

    function showCursor(e) {
        const rect = (currentLayer === 'red' ? drawingCanvas : drawingCanvasBlue).getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const penSize = currentLayer === 'red' ? penSizeRed : penSizeRed2;

        cursorCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);
        cursorCtx.beginPath();
        cursorCtx.arc(x, y, penSize / 2, 0, Math.PI * 2);
        cursorCtx.lineWidth = 2;
        cursorCtx.strokeStyle = isErasing ? 'gray' : 'black';
        cursorCtx.stroke();
    }

    function clearCursor() {
        cursorCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);
    }

    function toggleEraser() {
        isErasing = !isErasing;
        document.getElementById('eraserButton').style.backgroundColor = isErasing ? '#cccccc' : '#ffffff';
    }

    // Gaussian Blur function
    function gaussianBlur(ctx, width, height, radius) {
        const imageData = ctx.getImageData(0, 0, width, height);
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(imageData, 0, 0);

        ctx.filter = `blur(${radius}px)`;
        ctx.drawImage(tempCanvas, 0, 0);
        ctx.filter = 'none';
    }

    function updateDepthTexture() {
        const redData = drawingCtx.getImageData(0, 0, canvas.width, canvas.height);
        const redGray = new Uint8ClampedArray(redData.data.length);
        for (let i = 0; i < redData.data.length; i += 4) {
            const r = redData.data[i];
            const g = redData.data[i + 1];
            const b = redData.data[i + 2];
            const a = redData.data[i + 3];
            const gray = (0.299 * r + 0.587 * g + 0.114 * b) * penAlphaRed;
            redGray[i] = gray;
            redGray[i + 1] = gray;
            redGray[i + 2] = gray;
            redGray[i + 3] = a;
        }
        const redGrayImage = new ImageData(redGray, canvas.width, canvas.height);
        mixedCtx.putImageData(redGrayImage, 0, 0);

        const red2Data = drawingCtxBlue.getImageData(0, 0, canvas.width, canvas.height);
        const red2Gray = new Uint8ClampedArray(red2Data.data.length);
        for (let i = 0; i < red2Data.data.length; i += 4) {
            const r = red2Data.data[i];
            const g = red2Data.data[i + 1];
            const b = red2Data.data[i + 2];
            const a = red2Data.data[i + 3];
            const gray = (0.299 * r + 0.587 * g + 0.114 * b) * penAlphaRed2;
            red2Gray[i] = gray;
            red2Gray[i + 1] = gray;
            red2Gray[i + 2] = gray;
            red2Gray[i + 3] = a;
        }
        const red2GrayImage = new ImageData(red2Gray, canvas.width, canvas.height);
        mixedCtx.globalCompositeOperation = 'lighter';
        mixedCtx.putImageData(red2GrayImage, 0, 0);

        const mixedData = mixedCtx.getImageData(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < mixedData.data.length; i += 4) {
            mixedData.data[i] *= displacementAlpha;
            mixedData.data[i + 1] *= displacementAlpha;
            mixedData.data[i + 2] *= displacementAlpha;
        }
        mixedCtx.putImageData(mixedData, 0, 0);

        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, depthTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mixedCanvas);
        render(0);
    }

    // WebGL Animation
    function render(offset) {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, imageTexture);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, depthTexture);

        gl.uniform1f(gl.getUniformLocation(program, 'u_offset'), offset * 0.1);

        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    function animateUpDown(timestamp) {
        if (!animationStartTime) {
            animationStartTime = timestamp;
            // Clear mixedCanvas before starting
            mixedCtx.clearRect(0, 0, mixedCanvas.width, mixedCanvas.height);

            // Calculate displacement map anew from the latest data
            const redData = drawingCtx.getImageData(0, 0, canvas.width, canvas.height);
            const redGray = new Uint8ClampedArray(redData.data.length);
            for (let i = 0; i < redData.data.length; i += 4) {
                const r = redData.data[i];
                const g = redData.data[i + 1];
                const b = redData.data[i + 2];
                const a = redData.data[i + 3];
                const gray = (0.299 * r + 0.587 * g + 0.114 * b) * penAlphaRed;
                redGray[i] = gray;
                redGray[i + 1] = gray;
                redGray[i + 2] = gray;
                redGray[i + 3] = a;
            }
            const redGrayImage = new ImageData(redGray, canvas.width, canvas.height);
            mixedCtx.putImageData(redGrayImage, 0, 0);

            const red2Data = drawingCtxBlue.getImageData(0, 0, canvas.width, canvas.height);
            const red2Gray = new Uint8ClampedArray(red2Data.data.length);
            for (let i = 0; i < red2Data.data.length; i += 4) {
                const r = red2Data.data[i];
                const g = red2Data.data[i + 1];
                const b = red2Data.data[i + 2];
                const a = red2Data.data[i + 3];
                const gray = (0.299 * r + 0.587 * g + 0.114 * b) * penAlphaRed2;
                red2Gray[i] = gray;
                red2Gray[i + 1] = gray;
                red2Gray[i + 2] = gray;
                red2Gray[i + 3] = a;
            }
            const red2GrayImage = new ImageData(red2Gray, canvas.width, canvas.height);
            mixedCtx.globalCompositeOperation = 'lighter';
            mixedCtx.putImageData(red2GrayImage, 0, 0);

            const mixedData = mixedCtx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < mixedData.data.length; i += 4) {
                mixedData.data[i] *= displacementAlpha;
                mixedData.data[i + 1] *= displacementAlpha;
                mixedData.data[i + 2] *= displacementAlpha;
            }
            mixedCtx.putImageData(mixedData, 0, 0);

            // Apply Gaussian Blur after clearing and recalculating
            gaussianBlur(mixedCtx, canvas.width, canvas.height, gaussianBlurValue);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, depthTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mixedCanvas);
        }

        const elapsed = (timestamp - animationStartTime) / 1000;
        const cycleDuration = 2.0;

        const offset = Math.sin(elapsed * Math.PI / cycleDuration);

        render(offset);

        if (isAnimating) {
            requestAnimationFrame(animateUpDown);
        } else {
            drawingCanvas.style.zIndex = "998";
            drawingCanvasBlue.style.zIndex = "998";
            animationStartTime = null;
            render(0);
        }
    }

    function startAutoUpDown() {
        drawingCanvas.style.zIndex = "0";
        drawingCanvasBlue.style.zIndex = "0";
        animationStartTime = null;
        isAnimating = true;
        requestAnimationFrame(animateUpDown);
    }

    // Function to change pen color and stop animation
    function changeColor(layer) {
        if (isAnimating) {
            isAnimating = false;
            drawingCanvas.style.zIndex = "998";
            drawingCanvasBlue.style.zIndex = "998";
            render(0);
        } else {
            currentLayer = layer;
            isErasing = false;
            document.getElementById('eraserButton').style.backgroundColor = '#ffffff';
            const color = prompt(`กรุณาใส่สีสำหรับ ${layer} (เช่น red, #FF0000):`, 'red');
            if (color) {
                if (layer === 'red') {
                    penColor = color;
                    document.getElementById('colorButton').style.backgroundColor = color;
                    document.getElementById('colorButton').textContent = color;
                } else {
                    penColor = color;
                    document.getElementById('red2Button').style.backgroundColor = color;
                    document.getElementById('red2Button').textContent = color;
                }
            }
        }
    }

    // Function to load a new image
    function loadNewImage(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                img.src = e.target.result;
                img.onload = function() {
                    resizeCanvas();
                    setupDrawingCanvas();
                    setupCursorCanvas();
                    initWebGL();
                    render(0);
                };
            };
            reader.readAsDataURL(file);
        }
    }

    window.addEventListener('resize', function() {
        resizeCanvas();
        setupDrawingCanvas();
        setupCursorCanvas();
        initWebGL();
        render(0);
    });
</script>

</body>
</html>